use serde_derive::*;

#[derive(Clone, Copy, Debug, Deserialize)]
pub struct BubblerConfig {
    /// Minimum delta time used for the simulation, smaller is the value, stabler but slower is the simulation
    #[serde(default = "default_dt_min")]
    pub dt_min: f32,

    /// Min-Max threshold for generating diffuse material due to Wave Crest
    #[serde(default = "default_tau_wc")]
    pub tau_wc: (f32, f32),
    /// Min-Max threshold for generating diffuse material due to Trapped Air
    #[serde(default = "default_tau_ta")]
    pub tau_ta: (f32, f32),
    /// Min-Max threshold for generating diffuse material due to kinetic energy of the particles
    #[serde(default = "default_tau_k")]
    pub tau_k: (f32, f32),

    /// Number of particles generated on wave crests per seconds (per particles)
    #[serde(default = "default_k_wc")]
    pub k_wc: f32,
    /// Number of particles generated by trapped air per seconds (per particles)
    #[serde(default = "default_k_ta")]
    pub k_ta: f32,

    /// Min-max lifetimes of a diffuse particle in seconds
    #[serde(default = "default_lifetime")]
    pub lifetime: (f32, f32),

    /// Number of neighbours in the fluid that categorize diffuse particle as Spray
    #[serde(default = "default_interval_neighbours_spray")]
    pub interval_neighbours_spray: (usize, usize),
    /// Number of neighbours in the fluid that categorize diffuse particle as Foam
    #[serde(default = "default_interval_neighbours_foam")]
    pub interval_neighbours_foam: (usize, usize),
    /// Number of neighbours in the fluid that categorize diffuse particle as Bubble
    #[serde(default = "default_interval_neighbours_bubble")]
    pub interval_neighbours_bubble: (usize, usize),

    /// Coefficient that controls the buoyancy of a bubble particle. The buoyancy is a force that counter attacks the gravity (here used as `-k_b*g`)
    #[serde(default = "default_k_b")]
    pub k_b: f32,
    /// Coefficient that the drag effect coefficient of a bubble particle, i.e., how much a bubble will follow the flow of the fluid
    ///     (setting it to 1 leads to bubbles that are immediately dragged into the flow direction of the fluid)
    #[serde(default = "default_k_d")]
    pub k_d: f32,

    /// Threshold value used to help distinguish real-crate crest from edges (v̂_i · n̂_i < threshold_wc_normal_direction => ignore particle)
    #[serde(default = "default_threshold_wc_normal_direction")]
    pub threshold_wc_normal_direction: f32,
}

fn default_dt_min() -> f32 { 1. / 120.0 }

fn default_tau_wc() -> (f32, f32) { (1.0, 6.0) }

fn default_tau_ta() -> (f32, f32) { (1.0, 4.0) }

fn default_tau_k() -> (f32, f32) { (0.05, 0.1) }

fn default_k_wc() -> f32 { 10. / default_dt_min() }

fn default_k_ta() -> f32 { 10. / default_dt_min() }

fn default_lifetime() -> (f32, f32) { (0.4, 1.3) }

fn default_interval_neighbours_spray() -> (usize, usize) { (0, 6) }

fn default_interval_neighbours_foam() -> (usize, usize) { (7, 19) }

fn default_interval_neighbours_bubble() -> (usize, usize) { (20, usize::max_value()) }

fn default_k_b() -> f32 { 0.7 }

fn default_k_d() -> f32 { 0.9 }

fn default_threshold_wc_normal_direction() -> f32 { 0.6 }

impl Default for BubblerConfig {
    fn default() -> Self {
        let dt_min = default_dt_min();
        BubblerConfig {
            dt_min,

            tau_wc: default_tau_wc(),
            tau_ta: default_tau_ta(),
            tau_k: default_tau_k(),

            // FIXME: those value are totally random, we must find correct ones
            k_wc: default_k_wc(),
            k_ta: default_k_ta(),
            // FIXME-END;

            lifetime: default_lifetime(),

            interval_neighbours_spray: default_interval_neighbours_spray(),
            interval_neighbours_foam: default_interval_neighbours_foam(),
            interval_neighbours_bubble: default_interval_neighbours_bubble(),

            // FIXME: those value are kind of random, we must find correct ones
            k_b: default_k_b(),
            k_d: default_k_d(),
            // FIXME-END;

            threshold_wc_normal_direction: default_threshold_wc_normal_direction(),
        }
    }
}

fn is_valid_range<T: PartialOrd>(x: &(T, T)) -> bool {
    x.0 <= x.1
}

fn range_overlaps(x: &(usize, usize), y: &(usize, usize)) -> bool {
    x.0 <= y.1 && y.0 <= x.1
}

impl BubblerConfig {
    pub fn assert_valid(&self) {
        assert!(is_valid_range(&self.lifetime));
        assert!(is_valid_range(&self.interval_neighbours_bubble));
        assert!(is_valid_range(&self.interval_neighbours_foam));
        assert!(is_valid_range(&self.interval_neighbours_spray));
        assert!(is_valid_range(&self.tau_wc));
        assert!(is_valid_range(&self.tau_ta));
        assert!(is_valid_range(&self.tau_k));

        // ensure that the coefficient are positives because we can't generate a negative number of particles
        assert!(self.k_wc >= 0.0);
        assert!(self.k_ta >= 0.0);

        // if the ranges overlaps, some types of particles won't be generated correctly (in fact, it'll depend on the order of the type test of the particle)
        assert!(!range_overlaps(&self.interval_neighbours_bubble, &self.interval_neighbours_foam));
        assert!(!range_overlaps(&self.interval_neighbours_foam, &self.interval_neighbours_spray));
        assert!(!range_overlaps(&self.interval_neighbours_spray, &self.interval_neighbours_bubble));

        // null number of neighbours for bubble or foam will lead to incorrect (NaN) velocities
        assert!(self.interval_neighbours_bubble.0 > 0);
        assert!(self.interval_neighbours_foam.0 > 0);

        assert!((0.0..=1.0).contains(&self.threshold_wc_normal_direction));
    }
}
